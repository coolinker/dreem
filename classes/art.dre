<!-- The MIT License (MIT)

Copyright ( c ) 2014 Teem2 LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. -->

  <!--/**
     * @class dr.art
     * @extends dr.abstractart
     * Vector graphics support using svg.
     *
     * This example shows how to load an existing svg
     *
     *     @example
     *     <art width="100" height="100" src="/images/siemens-clock.svg">
     *     </art>
     *
     * Paths within a svg can be selected using path. Path can be an index or
     * the name of the <g> element.
     *
     *     @example
     *     <art width="100" height="100" src="/images/cursorshapes.svg" path="0" stroke="coral" fill="coral">
     *       <handler event="onclick">
     *         this.path = this.path ^ 1;
     *         this.setAttribute('path', this.path);
     *         if (!this.zoom) this.zoom = 1.25;
     *         this.animate({width: this.zoom * this.width, height: this.zoom * this.height});
     *         this.zoom = 1.0 / this.zoom;
     *        </handler>
     *     </art>
     *
     */-->    

      <!--/**
        * @attribute {Boolean} inline [inline=false]
        * Set to true if the svg contents is found inline, as a comment
        */-->

      <!--/**
        * @attribute {String} src
        * The svg contents to load
        */-->

      <!--/**
        * @attribute {String} path
        * The svg path element to display. Path can either be a named path, or a 0-based index of the path to display.
        */-->

      <!--/**
        * @event onartready
        * Fired when the art is loaded and ready
        */-->

      <!--/**
        * @event ontweening
        * Fired when the art has animated to the next position
        */-->

    <class name="art" type="coffee" scriptincludes="/lib/snap.svg-min.js" clickable="true">
      <attribute name="inline" value="false" type="boolean"></attribute>
      <attribute name="src" value="" type="string"></attribute>

      <attribute name="path" value="" type="string"></attribute>
      <handler event="onpath">
        return if @path.length == 0 or not @container
        @animate_path(@path)
      </handler>

      <setter name="src" args="src">
        return if !src
        return if @src == src
        @src = src
      </setter>

      <handler event="oninit">
        # Retrieve the entire inline contents
        if @inline
          @inline_data = @sprite.getText()
          @sprite.setText('')
          @loadInline() if @inline

        @loadFromFile() if @src
      </handler>

      <method name="setAttribute" args="name, value">
        # If debug=true, show attributes that pass through to the svg
        debug = window.location.search.indexOf('debug') > 0
        if debug
          @expectedAttr = ['x','y','width','height','parent','clip','id','scrollable','clickable','visible','$textcontent','$tagname','inline','src','path'] unless @expectedAttr
          unless name in @expectedAttr
            console.warn('Passing attribute', name, 'to svg')
      </method>


      <method name="show_path" args="name">
        # Retrieve an svg path given its name, or index
        path = @get_path(name)
        if path
          d1 = path[0].getAttribute('d')
          @createSnap()
          @snappath = @snap.path(d1)
      </method>


      <method name="animate_path" args="name,msec,bounce,params">
        # Animate the path, as well as specified params
        return @show_path(name) if !@snap

        msec = 1000 if !msec
        bounce = mina.bounce if !bounce
        params = {} if !params
        # console.log('msec, params', msec, params)

        # Animate to a given path, by name, or id
        path = @get_path(name)
        if path
          d1 = path[0].getAttribute('d')
          params['d'] = d1
          _this = this
          @snappath.animate params, msec, bounce, ->
            _this.sendEvent('tweening')
      </method>



      <method name="createDOM">
        # Create a div to handle resizing of the graphics
        return if @container      

        @container = document.createElement('div')
        #@container.setAttribute('style', 'overflow: hidden; width: 100%; height: 100%')
        @container.$init = true;  # Prevent warnings
        @sprite.el.appendChild(@container)
      </method>

      <method name="createSnap">
        return if @snap
        @snap = Snap()

        # Create another div to handle resizing
        @snapcontainer = document.createElement('div')
        @snapcontainer.setAttribute('style', 'overflow: hidden; width: 100%; height: 100%')
        @sprite.el.appendChild(@snapcontainer)

        @snap.appendTo(@snapcontainer)

        # Set the viewBox to the bounding box of all paths
        rect = @get_bounding_box()
        viewbox = rect.x + ' ' + rect.y + ' ' + rect.width + ' ' + rect.height
        @snap.attr({viewBox: viewbox})

        # If this object is clickable, listen to mouse events
        if @clickable
          _this = this
          @snap.click -> _this.sendEvent('click')
          @snap.mousedown -> _this.sendEvent('mousedown')
          @snap.mouseup -> _this.sendEvent('mouseup')
          @snap.mousemove -> _this.sendEvent('mousemove')
          @snap.mouseover -> _this.sendEvent('mouseover')
          @snap.mouseout -> _this.sendEvent('mouseout')

        # Hide the static svg object
        @hide_art()

      </method>


      <method name="hide_art", args="fixed">
        # Hide either fixed art (fixed=true or missing) or snap (false)
        fixed = true if not fixed?
        $(@container).hide() if @container and fixed
        $(@snapcontainer).hide() if @snapcontainer and not fixed
      </method>

      <method name="get_path" args="name">
        # Read the path information from the svg using id and then index
        return null if !@container

        # Assume name is a named element
        path = $(@container).find('svg').find('g#'+name).find('path')
        return path if path.length == 1

        # Try using name as an index
        index = parseInt(name)
        return null if isNaN(index)
        elements = $(@container).find('svg').find('g').find('path')
        return null if (elements.length-1) < index

        return $(elements[index])
      </method>

      <method name="get_paths">
        # Get every path specified in the svg
        dom = @container
        return null if !dom

        paths = $(dom).find('svg').find('g').find('path')
        return paths
      </method>

      <method name="get_bounding_box">
        # Get the bounding box of all the paths
        paths = @get_paths()
        for path, index in paths
          box = path.getBBox()
          if !rect
            rect = jQuery.extend({}, box)   # clone so IE doesn't error
            x1 = box.x + box.width
            y1 = box.y + box.height
          else
            rect.x = Math.min(rect.x, box.x)
            rect.y = Math.min(rect.y, box.y)
            x1 = Math.max(x1, box.x + box.width)
            y1 = Math.max(y1, box.y + box.height)
        if rect
          # Use floor/ceil to create a viewBox that covers all paths
          x1 = Math.ceil(x1)
          y1 = Math.ceil(y1)
          rect.x = Math.floor(rect.x)
          rect.y = Math.floor(rect.y)
          rect.width = x1 - rect.x
          rect.height = y1 - rect.y

        return rect
      </method>

      <handler event="onartready" method="normalizeArt"></handler>

      <method name="normalizeArt">
        return unless @container

        # Normalize the svg by setting width and height to 100%, and
        # adding a viewBox if one is missing
        elements = $(@container).find('svg')
        for svg, index in elements
          # If width_orig is found it means this method has already run
          continue if svg.getAttribute('width_orig')

          # Rewrite width and height, saving the original values
          w = svg.getAttribute('width')
          h = svg.getAttribute('height')
          svg.setAttribute('width_orig', w)
          svg.setAttribute('height_orig', h)
          svg.setAttribute('width', '100%')
          svg.setAttribute('height', '100%')
          # console.log('svg size set from ', w, h)

          # Add a viewPort if one is missing and w,h was absolute
          viewBox = svg.getAttribute('viewBox')
          if w && h && !viewBox
            # Add a viewBox to match the size
            viewBox = '0 0 ' + w + ' ' + h
            svg.setAttribute('viewBox', viewBox)
            # console.log('new viewBox', viewBox)

          # Add click events
          if @clickable
            _this = this
            $(svg).on 'click', -> _this.sendEvent('click')
            $(svg).on 'mousedown', -> _this.sendEvent('mousedown')
            $(svg).on 'mouseup', -> _this.sendEvent('mouseup')
            $(svg).on 'mousemove', -> _this.sendEvent('mousemove')
            $(svg).on 'mouseover', -> _this.sendEvent('mouseover')
            $(svg).on 'mouseout', -> _this.sendEvent('mouseout')

        # Move to the specified path
        @animate_path(@path) if @path.length > 0
      </method>

      <method name="loadInline">
        # Load inline svg
        @createDOM()

        @inline_data = @inline_data.trim()
        # Remove comments. Comments are used to prevent compile errors
        match = new RegExp(/^\s*\<\!--(.*)--\>/).exec(@inline_data);
        if !!match
          @inline_data = match[1]

        $(@container).html(@inline_data)

        # Refresh the div
        $(@container).html($(@container).html())

        # Trigger artready
        #TODO Can this be improved? I tried binding to DOM events, svg loaded
        _this = this
        setTimeout ( ->
          _this.sendEvent('artready')
        ), 1
      </method>

      <method name="loadFromFile">
        # Load an svg file
        @createDOM()

        # Fire onload when the graphic is loaded
        _this = this
        $(@container).load @src, ->
          # Generate onartready event
          _this.sendEvent('artready')
      </method>

    </class>
