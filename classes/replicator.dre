<!-- The MIT License (MIT)

Copyright ( c ) 2014 Teem2 LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. -->
  <!--/**
     * @class dr.replicator
     * @extends dr.node
     * Handles replication and data binding.
     *
     * This example shows how to use a filterexpression regex to filter the results to only numbers:
     *
     *     @example
     *     <simplelayout></simplelayout>
     *     <text onclick="repl.setAttribute('filterexpression', '[^\\d]');">Click to change filter</text>
     *     <replicator id="repl" classname="text" data="['a',1,'b',2,'c',3,4,5]" filterexpression="\d"></replicator>
     */--> 
    <class name="replicator" type="coffee" extends="node" scriptincludes="/lib/json-path+json-ptr-0.1.3.min.js">
      <!--/**
        * @cfg {Boolean} [pooling=false]
        * If true, reuse views when replicating.
        */-->
      <attribute name="pooling" value="false" type="boolean"></attribute>
      <!--/**
        * @cfg {Array} [data=[]]
        * The list of items to replicate. If replicator.datapath is set, it is converted to a list and stored here.
        */-->
      <attribute name="data" value="[]" type="expression"></attribute>
      <!--/**
        * @cfg {String} classname (required)
        * The name of the class to be replicated.
        */-->
      <attribute name="classname" value="" type="string"></attribute>
      <!--/**
        * @cfg {String} datapath
        * The name of the datapath expression to be replicated.
        * See [https://github.com/flitbit/json-path](https://github.com/flitbit/json-path) for details.
        */-->
      <setter name="datapath" args="datapath">
        return unless datapath
        # console.log('evaluating datapath', datapath)
        re = /^\$([^\/]+)/
        match = datapath.match(re)
        if match and match[1]
          # absolute datapath
          @setAttribute('_dataset', match[1])
          datapath = datapath.replace(re, '')

        @datapath = datapath
        @sendEvent('datapath', datapath)

        @parsedpath = JsonPath.parseSelector(datapath)
        # console.log('evaluated datapath', datapath, @parsedpath)
      </setter>
      <!-- TODO: why can't this attribute/setter be named _dataset? -->
<!--       TODO: attribute value is overwritten by "" later!!!
      <attribute name="_dataset" value="" type="string"></attribute> -->
      <setter name="_dataset" args="dataset">
        return unless dataset
        @dataset = dr.datasets[dataset]
        @_dataset = dataset

        # console.log('listening to dataset', dataset, dr.datasets, @dataset, @_dataset)
        @listenTo(@dataset, 'data', (data) =>
          # console.log('callback', @, data)
          @setAttribute('data', data)
        )
        @sendEvent('dataset', @dataset)
      </setter>
      <!-- TODO: make this a relative datapath -->
      <!--/**
        * @cfg {String} [sortfield=""]
        * The field in the data to use for sorting. Only sort then this 
        */-->
      <attribute name="sortfield" value="" type="string"></attribute>
      <!--/**
        * @cfg {Boolean} [sortasc=true]
        * If true, sort ascending.
        */-->
      <attribute name="sortasc" value="true" type="boolean"></attribute>
      <!--/**
        * @cfg {String} [filterexpression=""]
        * If defined, results will be filtered against a regex. 
        */-->
      <attribute name="filterexpression" value="" type="string"></attribute>
      <setter name="filterexpression" args="regex">
        _filterexpression = new RegExp(regex)
        # console.log('filtering on', regex, _filterexpression)
        @_filterexpressionfunc = (value) ->
          return (value + '').match(_filterexpression) if (value)
        @doReplication()
      </setter>
      <attribute name="lazycount" value="Infinity" type="number"></attribute>
      <handler event="onsortfield">
        # console.log 'onsortfield', @sortfield, @data
        @buildsortfunc()
        @applyData()
      </handler>
      <handler event="onsortasc">
        # console.log 'onsortasc', @sortasc, @data
        @buildsortfunc()
        @applyData()
      </handler>
      <method name="buildsortfunc">
        if @sortfield
          sortfield = @sortfield
          sortasc = @sortasc
          @sortfunc = (a, b) ->
            keyA = a[sortfield]
            keyB = b[sortfield]
            # Compare the 2 sort fields
            result = 0
            if keyA > keyB
              result = 1
            else if keyA < keyB
              result = -1

            # console.log sortfield, sortasc
            result = -result if (not sortasc)
            result
        else
          @sortfunc = null
      </method>
      <handler event="oninit" method="applyData"></handler>
      <handler event="onclassname" method="applyData"></handler>
      <handler event="ondata" method="applyData"></handler>
      <handler event="ondatapath" method="applyData"></handler>
      <handler event="ondestroy" method="clear"></handler>
      <method name="updateData" args="data">
        # remove dataset declaration
        re = /^\$([^\/]+)/
        @dataset.updateData(@datapath.replace(re, ''), data);
      </method>
      <method name="clear">
        # @parent.setAttribute('display', 'none')
        if @children
          for child in @children
            # console.log 'destroying child', child
            child.destroy()
        @children = []
        # @parent.setAttribute('display', null)
      </method>
      <method name="applyData">
        return unless @inited and @parent and @classname
        # console.log('applyData', @data, @classname, @parent, @children, @, @inited)

        unless @classname of dr
          console.warn 'missing class for replicator', @classname, 'skipping replication'
          return

        return if @locked

        if @datapath
          if @_dataset
            # absolute datapath
            # console.log 'evaluating absolute datapath', @datapath, @_dataset
            unless @dataset
              console.warn 'missing dataset', @_dataset
              return

            if @datapath == '$' + @_dataset
              # console.log('dataset only', @datapath, @dataset)
              # replicate an instance with data attribute set to the dataset
              data = [@dataset]
            else
              # console.log('evaluating absolute selector', @datapath, @dataset.data, @parsedpath)
              data = JsonPath.executeSelectors(@dataset.data, @parsedpath, @filterfunction?.bind(@))
          else 
            # relative datapath, look for dataset reference in parents
            parentdata = @_findInParents('data')
            if parentdata?
              # console.log 'found dataset in parent ', parentdata
              if parentdata.$tagname is 'dataset' and parentdata.data
                # console.log 'found parentdata.data', parentdata
                parentdata = parentdata.data 
              # console.log('executing relative selector', @datapath, @parsedpath, parentdata)
              data = JsonPath.executeSelectors(parentdata, @parsedpath, @filterfunction?.bind(@))
              # console.log('looking for data', @datapath, parentdata, data)
            else
              console.warn('No parent datapath found', @datapath, @)
          @data = data
        else
          # no datapath
          data = @data

        return unless @data

        @_origdata = @data

        if @data.length > @lazycount
          setTimeout(() =>
            @doReplication()
          , 0);
        else
          @doReplication()
      </method>
      <method name="doReplication">
        return unless @data and @parent
        locked = @locked
        @locked = true

        if @filterexpression and @_filterexpressionfunc
          @data = @_origdata.filter(@_filterexpressionfunc)
          # console.log('_filterexpressionfunc', @_filterexpressionfunc, @data, @_origdata)

        @data.sort(@sortfunc) if (@sortfunc)

        if @parent.layouts
          for layout in @parent.layouts
            layout.setAttribute('locked', true)

        #console.log @data.length
        if @pooling and @children and @children.length == @data.length
          for child, i in @children
            datum = @data[i]
            # console.log 'replicator updating', i, child, 'in', datum
            child.setAttribute('data', datum)
        else
          @clear()
          for datum in @data
            # console.log 'replicator creating', @classname, 'in', @parent
            child = new dr[@classname](null, {data: datum, parent: @parent, replicator: @})
            # console.log 'replicator created', @classname, child, child.data
            @children.push(child)

        # init constraints for all children created
        child.initConstraints() if child

        if @parent.layouts
          for layout in @parent.layouts
            layout.setAttribute('locked', false)

        @locked = locked        
      </method>
    </class>