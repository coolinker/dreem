<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.7.1

/*
 * The MIT License (MIT)
 * 
 * Copyright ( c ) 2014 Teem2 LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

(function() {
  var hackstyle,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  hackstyle = (function() {
    var origstyle, stylemap, styletap;
    stylemap = {
      left: &#39;x&#39;,
      top: &#39;y&#39;,
      &#39;background-color&#39;: &#39;bgcolor&#39;
    };
    origstyle = $.style;
    styletap = function(elem, name, value) {
      var returnval, view;
      returnval = origstyle.apply(this, arguments);
      name = stylemap[name] || name;
      view = elem.$view;
      if (view[name] !== value) {
        view.setAttribute(name, value, true);
      }
      return returnval;
    };
    return function(active) {
      if (active) {
        return $.style = styletap;
      } else {
        return $.style = origstyle;
      }
    };
  })();

  window.dr = (function() {
    var Class, Eventable, Events, Idle, Keyboard, Layout, Module, Mouse, Node, Sprite, StartEventable, State, View, Window, compiler, constraintScopes, dom, exports, idle, ignoredAttributes, mixOf, moduleKeywords, mouseEvents, _initConstraints;
    mixOf = function() {
      var Mixed, base, i, method, mixin, mixins, name, _i, _ref;
      base = arguments[0], mixins = 2 &lt;= arguments.length ? __slice.call(arguments, 1) : [];
      Mixed = (function(_super) {
        __extends(Mixed, _super);

        function Mixed() {
          return Mixed.__super__.constructor.apply(this, arguments);
        }

        return Mixed;

      })(base);
      for (i = _i = mixins.length - 1; _i &gt;= 0; i = _i += -1) {
        mixin = mixins[i];
        _ref = mixin.prototype;
        for (name in _ref) {
          method = _ref[name];
          Mixed.prototype[name] = method;
        }
      }
      return Mixed;
    };

<span id='Events'>    /**
</span>     * @class Events
     * @private
     * A lightweight event system, used internally.
     */
    Events = {

<span id='Events-method-bind'>      /**
</span>       * Binds an event to the current scope
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      bind: function(ev, callback) {
        var evs, name, _base, _i, _len;
        evs = ev.split(&#39; &#39;);
        if (!(this.hasOwnProperty(&#39;events&#39;) &amp;&amp; this.events)) {
          this.events = {};
        }
        for (_i = 0, _len = evs.length; _i &lt; _len; _i++) {
          name = evs[_i];
          (_base = this.events)[name] || (_base[name] = []);
          this.events[name].push(callback);
        }
        return this;
      },

<span id='Events-method-one'>      /**
</span>       * Binds an event to the current scope, automatically unbinds when the event fires
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      one: function(ev, callback) {
        this.bind(ev, function() {
          this.unbind(ev, arguments.callee);
          return callback.apply(this, arguments);
        });
        return this;
      },

<span id='Events-method-trigger'>      /**
</span>       * Fires an event
       * @param {String} ev the name of the event to fire
       */
      trigger: function() {
        var args, callback, ev, list, _i, _len, _ref;
        args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
        ev = args.shift();
        list = this.hasOwnProperty(&#39;events&#39;) &amp;&amp; ((_ref = this.events) != null ? _ref[ev] : void 0);
        if (!list) {
          return;
        }
        for (_i = 0, _len = list.length; _i &lt; _len; _i++) {
          callback = list[_i];
          if (callback.apply(this, args) === false) {
            break;
          }
        }
        return this;
      },

<span id='Events-method-listenTo'>      /**
</span>       * Listens for an event on a specific scope
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      listenTo: function(obj, ev, callback) {
        obj.bind(ev, callback);
        this.listeningTo || (this.listeningTo = []);
        this.listeningTo.push({
          obj: obj,
          ev: ev,
          callback: callback
        });
        return this;
      },

<span id='Events-method-listenToOnce'>      /**
</span>       * Only listens for an event one time
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event is fired
       */
      listenToOnce: function(obj, ev, callback) {
        var listeningToOnce;
        listeningToOnce = this.listeningToOnce || (this.listeningToOnce = []);
        listeningToOnce.push(obj);
        obj.one(ev, function() {
          var idx;
          idx = listeningToOnce.indexOf(obj);
          if (idx !== -1) {
            listeningToOnce.splice(idx, 1);
          }
          return callback.apply(this, arguments);
        });
        return this;
      },

<span id='Events-method-stopListening'>      /**
</span>       * Stops listening for an event on a given scope
       * @param {Object} obj scope to listen for events on
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event would have been fired
       */
      stopListening: function(obj, ev, callback) {
        var idx, index, listeningTo, val, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (obj) {
          obj.unbind(ev, callback);
          _ref = [this.listeningTo, this.listeningToOnce];
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            listeningTo = _ref[_i];
            if (!listeningTo) {
              continue;
            }
            idx = listeningTo.indexOf(obj);
            if (idx &gt; -1) {
              listeningTo.splice(idx, 1);
            } else {
              for (index = _j = 0, _len1 = listeningTo.length; _j &lt; _len1; index = ++_j) {
                val = listeningTo[index];
                if (obj === val.obj &amp;&amp; ev === val.ev &amp;&amp; callback === val.callback) {
                  listeningTo.splice(index, 1);
                  break;
                }
              }
            }
          }
        } else {
          _ref1 = this.listeningTo;
          for (_k = 0, _len2 = _ref1.length; _k &lt; _len2; _k++) {
            _ref2 = _ref1[_k], obj = _ref2.obj, ev = _ref2.ev, callback = _ref2.callback;
            obj.unbind(ev, callback);
          }
          this.listeningTo = void 0;
        }
        return this;
      },

<span id='Events-method-unbind'>      /**
</span>       * Stops listening for an event on the current scope
       * @param {String} ev the name of the event
       * @param {Function} callback called when the event would have been fired
       */
      unbind: function(ev, callback) {
        var cb, evs, i, list, name, _i, _j, _len, _len1, _ref;
        if (!ev) {
          this.events = {};
          return this;
        }
        evs = ev.split(&#39; &#39;);
        for (_i = 0, _len = evs.length; _i &lt; _len; _i++) {
          name = evs[_i];
          list = (_ref = this.events) != null ? _ref[name] : void 0;
          if (!list) {
            continue;
          }
          if (!callback) {
            delete this.events[name];
            continue;
          }
          for (i = _j = 0, _len1 = list.length; _j &lt; _len1; i = ++_j) {
            cb = list[i];
            if (!(cb === callback)) {
              continue;
            }
            list = list.slice();
            list.splice(i, 1);
            this.events[name] = list;
            break;
          }
        }
        return this;
      }
    };

<span id='Module'>    /**
</span>     * @class Module
     * @private
     * Adds basic mixin support.
     */
    moduleKeywords = [&#39;included&#39;, &#39;extended&#39;];
    Module = (function() {
      function Module() {}


<span id='Module-method-include'>      /**
</span>       * Includes a mixin in the current scope
       * @param {Object} obj the object to be mixed in
       */

      Module.include = function(obj) {
        var key, value, _ref;
        if (!obj) {
          throw new Error(&#39;include(obj) requires obj&#39;);
        }
        for (key in obj) {
          value = obj[key];
          if (__indexOf.call(moduleKeywords, key) &lt; 0) {
            this.prototype[key] = value;
          }
        }
        if ((_ref = obj.included) != null) {
          _ref.call(this, obj);
        }
        return this;
      };

      return Module;

    })();

<span id='Eventable'>    /**
</span>     * @class Eventable
     * @extends Module
     * The baseclass used by everything in dreem. Adds higher level event APIs.
     */
    Eventable = (function(_super) {

<span id='Eventable-method-include'>      /**
</span>       * @method include
       * @hide
       */
      var typemappings;

      __extends(Eventable, _super);

      function Eventable() {
        return Eventable.__super__.constructor.apply(this, arguments);
      }

      Eventable.include(Events);

      typemappings = {
        number: parseFloat,
        boolean: function(val) {
          if (typeof val === &#39;string&#39;) {
            return val === &#39;true&#39;;
          } else {
            return !!val;
          }
        },
        string: function(val) {
          return val + &#39;&#39;;
        },
        json: function(val) {
          return JSON.parse(val);
        },
        expression: function(val) {
          if (typeof val !== &#39;string&#39;) {
            return val;
          }
          return eval(val);
        }
      };


<span id='Eventable-method-setAttribute'>      /**
</span>       * Sets an attribute, calls a setter if there is one, then sends an event with the new value
       * @param {String} name the name of the attribute to set
       * @param value the value to set to
       */

      Eventable.prototype.setAttribute = function(name, value) {
        var type, _name;
        type = this.types[name];
        if (type) {
          value = typemappings[type](value);
        }
        if (typeof this[_name = &quot;set_&quot; + name] === &quot;function&quot;) {
          this[_name](value);
        }
        if (this[name] !== value) {
          this[name] = value;
        }
        this.sendEvent(name, value);
        return this;
      };


<span id='Eventable-method-sendEvent'>      /**
</span>       * Sends an event
       * @param {String} name the name of the event to send
       * @param value the value to send with the event
       */

      Eventable.prototype.sendEvent = function(name, value) {
        var _ref;
        if ((_ref = this.events) != null ? _ref[name] : void 0) {
          this.trigger(name, value, this);
        }
        return this;
      };


<span id='global-method-set'>      /**
</span>       * @ignore
       * Calls setAttribute for each name/value pair in the attributes object
       * @param {Object} attributes An object of name/value pairs to be set
       */

      Eventable.prototype.set = function(attributes) {
        var name, value;
        for (name in attributes) {
          value = attributes[name];
          this.setAttribute(name, value);
        }
        return this;
      };

      return Eventable;

    })(Module);
    compiler = (function() {
      var cacheKey, compile, compileCache, debug, exports, findBindings, localStorageWorks, scriptCache, strict, transform, usecache;
      localStorageWorks = (function() {
        var e, mod;
        mod = &#39;modernizr&#39;;
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (_error) {
          e = _error;
          return false;
        }
      })();
      usecache = window.location.search.indexOf(&#39;nocache&#39;) === -1;
      if (!localStorageWorks) {
        usecache = false;
      }
      debug = window.location.search.indexOf(&#39;debug&#39;) &gt; 0;
      strict = window.location.search.indexOf(&#39;strict&#39;) &gt; 0;
      cacheKey = &quot;compilecache&quot;;
      if (usecache &amp;&amp; cacheKey in localStorage) {
        compileCache = JSON.parse(localStorage[cacheKey]);
      } else {
        if (!usecache) {
          localStorage.clear;
        }
        compileCache = {
          bindings: {},
          script: {
            coffee: {}
          }
        };
        if (usecache) {
          localStorage[cacheKey] = JSON.stringify(compileCache);
        }
      }
      $(window).on(&#39;unload&#39;, function() {
        if (usecache) {
          return localStorage[cacheKey] = JSON.stringify(compileCache);
        }
      });
      findBindings = (function() {
        var bindingCache, propertyBindings, scopes;
        bindingCache = compileCache.bindings;
        scopes = null;
        propertyBindings = {
          MemberExpression: function(n) {
            var name;
            name = n.property.name;
            n = n.object;
            scopes.push({
              binding: acorn.stringify(n),
              property: name
            });
            return true;
          }
        };
        return function(expression) {
          var ast;
          if (usecache &amp;&amp; expression in bindingCache) {
            return bindingCache[expression];
          }
          ast = acorn.parse(expression);
          scopes = [];
          acorn.walkDown(ast, propertyBindings);
          return bindingCache[expression] = scopes;
        };
      })();
      transform = (function() {
        var coffeeCache, compilers;
        coffeeCache = compileCache.script.coffee;
        compilers = {
          coffee: function(script) {
            if (usecache &amp;&amp; script in coffeeCache) {
              return coffeeCache[script];
            }
            if (!window.CoffeeScript) {
              console.warn(&#39;missing coffee-script.js include&#39;);
              return;
            }
            if (script) {
              return coffeeCache[script] = CoffeeScript.compile(script, {
                bare: true
              });
            }
          }
        };
        return function(script, name) {
          if (script == null) {
            script = &#39;&#39;;
          }
          if (!(name in compilers)) {
            return script;
          }
          return compilers[name](script);
        };
      })();
      scriptCache = {};
      compile = function(script, args, name) {
        var argstring, e, func, key;
        if (script == null) {
          script = &#39;&#39;;
        }
        if (args == null) {
          args = [];
        }
        if (name == null) {
          name = &#39;&#39;;
        }
        argstring = args.join();
        key = script + argstring + name;
        if (key in scriptCache) {
          return scriptCache[key];
        }
        try {
          if (debug &amp;&amp; name) {
            if (strict) {
              script = &quot;\&quot;use strict\&quot;\n&quot; + script;
            }
            func = new Function(&quot;return function &quot; + name + &quot;(&quot; + argstring + &quot;){&quot; + script + &quot;}&quot;)();
          } else {
            func = new Function(args, script);
          }
          return scriptCache[key] = func;
        } catch (_error) {
          e = _error;
          return console.error(&#39;failed to compile&#39;, e.toString(), args, script);
        }
      };
      return exports = {
        compile: compile,
        transform: transform,
        findBindings: findBindings
      };
    })();
    constraintScopes = [];
    _initConstraints = function() {
      var constraint, _i, _len;
      for (_i = 0, _len = constraintScopes.length; _i &lt; _len; _i++) {
        constraint = constraintScopes[_i];
        constraint._bindConstraints();
      }
      return constraintScopes = [];
    };

<span id='dr-node'>    /**
</span>     * @class dr.node
     * @extends Eventable
     * The nonvisual base class for everything in dreem. Handles parent/child relationships between tags.
     * 
     * Nodes can contain methods, handlers, setters, constraints, attributes and other node instances.
     */
    Node = (function(_super) {

<span id='dr-node-cfg-name'>      /**
</span>       * @cfg {String} name 
       * Names this node in its parent scope so it can be referred to later.
       */

<span id='dr-node-cfg-id'>      /**
</span>       * @cfg {String} id 
       * Gives this node a global ID, which can be looked up in the global window object.
       * Take care to not override builtin globals, or override your own instances!
       */

<span id='dr-node-cfg-scriptincludes'>      /**
</span>       * @cfg {String} scriptincludes 
       * A comma separated list of URLs to javascript includes required as dependencies. Useful if you need to ensure a third party library is available.
       */
      var lateattributes, matchConstraint, _eventCallback, _installMethod;

      __extends(Node, _super);

      matchConstraint = /\${(.+)}/;

      lateattributes = [&#39;parent&#39;, &#39;name&#39;];

      function Node(el, attributes) {
        var args, deferbindings, method, name, reference, script, skiponinit, value, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        if (attributes == null) {
          attributes = {};
        }

<span id='dr-node-property-subnodes'>        /**
</span>         * @property {dr.node[]} subnodes
         * @readonly
         * An array of this node&#39;s child nodes
         */
        this.subnodes = [];
        this.types = (_ref = attributes.$types) != null ? _ref : {};
        delete attributes.$types;
        skiponinit = attributes.$skiponinit;
        delete attributes.$skiponinit;
        deferbindings = attributes.$deferbindings;
        delete attributes.$deferbindings;

        /*
         * @property {String} $textcontent
         * @readonly
         * Contains the textual contents of this node, if any
         */
        if (el != null ? el.textContent : void 0) {
          attributes.$textcontent = el.textContent;
        }
        if (attributes.$methods) {
          this.installMethods(attributes.$methods, attributes.$tagname);
          delete attributes.$methods;
        }
        if (attributes.$handlers) {
          this.installHandlers(attributes.$handlers, attributes.$tagname);
          _ref1 = attributes.$handlers;
          for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {
            _ref2 = _ref1[_i], name = _ref2.name, script = _ref2.script, args = _ref2.args, reference = _ref2.reference, method = _ref2.method;
            name = name.substr(2);
            if (__indexOf.call(mouseEvents, name) &gt;= 0) {
              if (attributes.clickable !== &quot;false&quot;) {
                attributes.clickable = true;
              }
            }
          }
          delete attributes.$handlers;
        }
        if (!deferbindings) {
          this._bindHandlers();
        }
        for (name in attributes) {
          value = attributes[name];
          if (__indexOf.call(lateattributes, name) &lt; 0) {
            this.bindAttribute(name, value, attributes.$tagname);
          }
        }
        if (this.constraints) {
          constraintScopes.push(this);
        }
        for (_j = 0, _len1 = lateattributes.length; _j &lt; _len1; _j++) {
          name = lateattributes[_j];
          if (attributes[name]) {
            this.setAttribute(name, attributes[name]);
          }
        }

<span id='dr-node-event-oninit'>        /**
</span>         * @event oninit 
         * Fired when this node and all its children are completely initialized
         * @param {dr.node} node The dr.node that fired the event
         */

<span id='dr-node-property-inited'>        /**
</span>         * @property {Boolean} inited
         * @readonly
         * True when this node and all its children are completely initialized
         */
        if (!skiponinit) {
          if (!this.inited) {
            this.inited = true;
            this.sendEvent(&#39;init&#39;, this);
          }
        }
      }

      Node.prototype.installMethods = function(methods, tagname, scope, callbackscope) {
        var allocation, args, method, methodlist, name, _results;
        if (scope == null) {
          scope = this;
        }
        if (callbackscope == null) {
          callbackscope = this;
        }
        _results = [];
        for (name in methods) {
          methodlist = methods[name];
          _results.push((function() {
            var _i, _len, _ref, _results1;
            _results1 = [];
            for (_i = 0, _len = methodlist.length; _i &lt; _len; _i++) {
              _ref = methodlist[_i], method = _ref.method, args = _ref.args, allocation = _ref.allocation;
              _results1.push(_installMethod(scope, name, compiler.compile(method, args, &quot;&quot; + tagname + &quot;$&quot; + name).bind(callbackscope), allocation));
            }
            return _results1;
          })());
        }
        return _results;
      };

      Node.prototype.installHandlers = function(handlers, tagname, scope) {
        var args, handler, method, name, reference, script, _i, _len, _results;
        if (scope == null) {
          scope = this;
        }
        if (this.handlers == null) {
          this.handlers = [];
        }
        _results = [];
        for (_i = 0, _len = handlers.length; _i &lt; _len; _i++) {
          handler = handlers[_i];
          name = handler.name, script = handler.script, args = handler.args, reference = handler.reference, method = handler.method;
          name = name.substr(2);
          if (method) {
            handler.callback = scope[method];
          } else {
            handler.callback = _eventCallback(name, script, scope, tagname, args);
          }
          _results.push(this.handlers.push({
            scope: this,
            name: name,
            callback: handler.callback,
            reference: reference
          }));
        }
        return _results;
      };

      Node.prototype.removeHandlers = function(handlers, tagname, scope) {
        var args, handler, method, name, reference, script, _i, _len, _results;
        if (scope == null) {
          scope = this;
        }
        _results = [];
        for (_i = 0, _len = handlers.length; _i &lt; _len; _i++) {
          handler = handlers[_i];
          name = handler.name, script = handler.script, args = handler.args, reference = handler.reference, method = handler.method;
          name = name.substr(2);
          if (reference != null) {
            _results.push(scope.stopListening(eval(reference), name, handler.callback));
          } else {
            _results.push(scope.unbind(name, handler.callback));
          }
        }
        return _results;
      };

      Node.prototype.bindAttribute = function(name, value, tagname) {
        var constraint;
        constraint = typeof value.match === &quot;function&quot; ? value.match(matchConstraint) : void 0;
        if (constraint) {
          return this._applyConstraint(name, constraint[1]);
        } else if (name.indexOf(&#39;on&#39;) === 0) {
          name = name.substr(2);
          return this.bind(name, _eventCallback(name, value, this, tagname));
        } else {
          return this.setAttribute(name, value);
        }
      };

      Node.prototype.initConstraints = function() {
        _initConstraints();
        return this;
      };

      _eventCallback = function(name, script, scope, tagname, fnargs) {
        var js;
        if (tagname == null) {
          tagname = &#39;&#39;;
        }
        if (fnargs == null) {
          fnargs = [&#39;value&#39;];
        }
        js = compiler.compile(script, fnargs, &quot;&quot; + tagname + &quot;$on&quot; + name);
        return function() {
          var args;
          if (arguments.length) {
            args = arguments;
          } else if (name in scope) {
            args = [scope[name]];
          } else {
            args = [];
          }
          return js.apply(scope, args);
        };
      };

      _installMethod = function(scope, methodname, method, allocation) {
        var meth, supr;
        if (methodname in scope) {
          supr = scope[methodname];
          meth = method;
          return scope[methodname] = function() {
            supr.apply(scope, arguments);
            return meth.apply(scope, arguments);
          };
        } else {
          return scope[methodname] = method;
        }
      };

      Node.prototype._applyConstraint = function(property, expression) {
        var bindexpression, bindings, scope, scopes, _i, _len;
        if (this.constraints == null) {
          this.constraints = {};
        }
        this.constraints[property] = {
          expression: expression,
          bindings: {}
        };
        bindings = this.constraints[property].bindings;
        scopes = compiler.findBindings(expression);
        for (_i = 0, _len = scopes.length; _i &lt; _len; _i++) {
          scope = scopes[_i];
          bindexpression = scope.binding;
          if (bindings[bindexpression] == null) {
            bindings[bindexpression] = [];
          }
          bindings[bindexpression].push(scope);
        }
      };

      Node.prototype._valueLookup = function(bindexpression) {
        return compiler.compile(&#39;return &#39; + bindexpression).bind(this);
      };

      Node.prototype._bindConstraints = function() {
        var bindexpression, binding, bindinglist, bindings, boundref, constraint, expression, fn, name, property, _i, _len, _ref;
        _ref = this.constraints;
        for (name in _ref) {
          constraint = _ref[name];
          bindings = constraint.bindings, expression = constraint.expression;
          fn = this._valueLookup(expression);
          constraint = this._constraintCallback(name, fn);
          for (bindexpression in bindings) {
            bindinglist = bindings[bindexpression];
            boundref = this._valueLookup(bindexpression)();
            if (boundref == null) {
              boundref = boundref.$view;
            }
            for (_i = 0, _len = bindinglist.length; _i &lt; _len; _i++) {
              binding = bindinglist[_i];
              property = binding.property;
              if (typeof boundref.bind === &quot;function&quot;) {
                boundref.bind(property, constraint);
              }
            }
          }
          this.setAttribute(name, fn());
        }
      };

      Node.prototype._bindHandlers = function() {
        var binding, callback, name, reference, refeval, scope, _i, _len, _ref;
        _ref = this.handlers;
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          binding = _ref[_i];
          scope = binding.scope, name = binding.name, callback = binding.callback, reference = binding.reference;
          if (reference) {
            refeval = this._valueLookup(reference)();
            scope.listenTo(refeval, name, callback);
          } else {
            scope.bind(name, callback);
          }
        }
        this.handlers = [];
      };

      Node.prototype._constraintCallback = function(name, fn) {
        return (function constraintCallback(){;
        this.setAttribute(name, fn());
        return }).bind(this);
      };

      Node.prototype.set_parent = function(parent) {
        if (parent instanceof Node) {
          if (this.name) {
            parent[this.name] = this;
          }
          parent.subnodes.push(this);

<span id='dr-node-event-onsubnodes'>          /**
</span>           * @event onsubnodes 
           * Fired when this node&#39;s subnodes array has changed
           * @param {dr.node} node The dr.node that fired the event
           */
          return parent.sendEvent(&#39;subnodes&#39;, this);
        }
      };

      Node.prototype.set_name = function(name) {
        return this.parent[name] = this;
      };

      Node.prototype.set_id = function(id) {
        return window[id] = this;
      };

      Node.prototype._removeFromParent = function(name) {
        var arr, index;
        if (!this.parent) {
          return;
        }
        arr = this.parent[name];
        index = arr.indexOf(this);
        if (index !== -1) {
          arr.splice(index, 1);
          this.parent.sendEvent(name, arr[index]);
        }
      };

      Node.prototype._findInParents = function(name) {
        var p;
        p = this.parent;
        while (p) {
          if (name in p) {
            return p[name];
          }
          p = p.parent;
        }
      };


<span id='dr-node-method-destroy'>      /**
</span>       * @method destroy
       * Destroys this node
       */


<span id='global-method-destroy'>      /**
</span>       * @ignore
       */

      Node.prototype.destroy = function(skipevents) {

<span id='dr-node-event-ondestroy'>        /**
</span>         * @event ondestroy 
         * Fired when this node and all its children are about to be destroyed
         * @param {dr.node} node The dr.node that fired the event
         */
        var subnode, _i, _len, _ref, _ref1;
        this.sendEvent(&#39;destroy&#39;, this);
        if (this.listeningTo) {
          this.stopListening();
        }
        this.unbind();
        if (((_ref = this.parent) != null ? _ref[this.name] : void 0) === this) {
          delete this.parent[this.name];
        }
        _ref1 = this.subnodes;
        for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {
          subnode = _ref1[_i];
          if (subnode != null) {
            subnode.destroy(true);
          }
        }
        if (!skipevents) {
          return this._removeFromParent(&#39;subnodes&#39;);
        }
      };

      return Node;

    })(Eventable);

<span id='Sprite'>    /**
</span>     * @class Sprite
     * @private
     * Abstracts the underlying visual primitives (currently HTML) from dreem&#39;s view system.
     */
    Sprite = (function() {
      var capabilities, fcamelCase, lastTouchDown, noop, rdashAlpha, stylemap, styleval;

      noop = function() {};

      stylemap = {
        x: &#39;left&#39;,
        y: &#39;top&#39;,
        bgcolor: &#39;backgroundColor&#39;,
        visible: &#39;display&#39;
      };

      styleval = {
        display: function(isVisible) {
          if (isVisible) {
            return &#39;&#39;;
          } else {
            return &#39;none&#39;;
          }
        }
      };

      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };

      rdashAlpha = /-([\da-z])/gi;

      capabilities = {
        touch: &#39;ontouchstart&#39; in window || &#39;onmsgesturechange&#39; in window
      };

      function Sprite(jqel, view, tagname) {
        if (tagname == null) {
          tagname = &#39;div&#39;;
        }
        this.handle = __bind(this.handle, this);
        this.touchHandler = __bind(this.touchHandler, this);
        this.animate = __bind(this.animate, this);
        if (jqel == null) {
          this.el = document.createElement(tagname);
          this.el.$init = true;
        } else if (jqel instanceof HTMLElement) {
          this.el = jqel;
        }
        this.el.$view = view;
        this.el.setAttribute(&#39;class&#39;, &#39;sprite&#39;);
      }

      Sprite.prototype.setStyle = function(name, value) {
        if (value == null) {
          value = &#39;&#39;;
        }
        if (name in stylemap) {
          name = stylemap[name];
        }
        if (name in styleval) {
          value = styleval[name](value);
        } else if (name.match(rdashAlpha)) {
          name = name.replace(rdashAlpha, fcamelCase);
        }
        return this.el.style[name] = value;
      };

      Sprite.prototype.set_parent = function(parent) {
        if (parent instanceof Sprite) {
          parent = parent.el;
        }
        return parent.appendChild(this.el);
      };

      Sprite.prototype.set_id = function(id) {
        return this.el.setAttribute(&#39;id&#39;, id);
      };

      Sprite.prototype.animate = function() {
        var name, value, _ref;
        if (this.jqel == null) {
          this.jqel = $(this.el);
        }
        _ref = arguments[0];
        for (name in _ref) {
          value = _ref[name];
          if (name in stylemap) {
            arguments[0][stylemap[name]] = value;
            delete arguments[0][name];
          }
        }
        return this.jqel.animate.apply(this.jqel, arguments);
      };

      Sprite.prototype.sendMouseEvent = function(type, first) {
        var simulatedEvent;
        simulatedEvent = document.createEvent(&#39;MouseEvent&#39;);
        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);
        first.target.dispatchEvent(simulatedEvent);
        if (first.target.$view &amp;&amp; first.target.$view.$tagname !== &#39;inputtext&#39;) {
          return event.preventDefault();
        }
      };

      lastTouchDown = null;

      Sprite.prototype.touchHandler = function(event) {
        var first, touches;
        touches = event.changedTouches;
        first = touches[0];
        switch (event.type) {
          case &#39;touchstart&#39;:
            this.sendMouseEvent(&#39;mousedown&#39;, first);
            return lastTouchDown = first.target;
          case &#39;touchmove&#39;:
            return this.sendMouseEvent(&#39;mousemove&#39;, first);
          case &#39;touchend&#39;:
            this.sendMouseEvent(&#39;mouseup&#39;, first);
            if (lastTouchDown === first.target) {
              this.sendMouseEvent(&#39;click&#39;, first);
              return lastTouchDown = null;
            }
        }
      };

      Sprite.prototype.set_clickable = function(clickable) {
        this.setStyle(&#39;pointer-events&#39;, clickable ? &#39;auto&#39; : &#39;none&#39;);
        this.setStyle(&#39;cursor&#39;, clickable ? &#39;pointer&#39; : &#39;&#39;);
        if (capabilities.touch) {
          document.addEventListener(&#39;touchstart&#39;, this.touchHandler, true);
          document.addEventListener(&#39;touchmove&#39;, this.touchHandler, true);
          document.addEventListener(&#39;touchend&#39;, this.touchHandler, true);
          return document.addEventListener(&#39;touchcancel&#39;, this.touchHandler, true);
        }
      };

      Sprite.prototype.destroy = function() {
        this.el.parentNode.removeChild(this.el);
        return this.el = this.jqel = null;
      };

      Sprite.prototype.set_clip = function(clip) {
        return this.setStyle(&#39;overflow&#39;, clip ? &#39;hidden&#39; : &#39;&#39;);
      };

      Sprite.prototype.text = function(text) {
        if (text != null) {
          return this.el.innerHTML = text;
        } else {
          return this.el.innerHTML;
        }
      };

      Sprite.prototype.value = function(value) {
        if (!this.input) {
          return;
        }
        if (value != null) {
          return this.input.value = value;
        } else {
          return this.input.value;
        }
      };

      Sprite.prototype.measureTextSize = function(multiline, width, resize) {
        this.el.setAttribute(&#39;class&#39;, &#39;sprite sprite-text noselect&#39;);
        if (multiline) {
          if (this._cachedwidth &gt; -1) {
            width = this._cachedwidth;
            this._cachedwidth = -1;
          }
          this.setStyle(&#39;width&#39;, width);
          this.setStyle(&#39;whiteSpace&#39;, &#39;normal&#39;);
        } else {
          this._cachedwidth = width;
          if (resize) {
            this.setStyle(&#39;width&#39;, &#39;auto&#39;);
          }
          this.setStyle(&#39;whiteSpace&#39;, &#39;&#39;);
        }
        return {
          width: this.el.clientWidth,
          height: this.el.clientHeight
        };
      };

      Sprite.prototype.handle = function(event) {
        var view;
        view = event.target.$view;
        if (!view) {
          return;
        }
        return view.sendEvent(event.type, view);
      };

      Sprite.prototype.createInputtextElement = function(text, multiline, width) {
        var input;
        input = document.createElement(&#39;input&#39;);
        input.setAttribute(&#39;type&#39;, &#39;text&#39;);
        input.setAttribute(&#39;value&#39;, text);
        input.setAttribute(&#39;style&#39;, &#39;border: none; outline: none; background-color:transparent;&#39;);
        this.el.setAttribute(&#39;class&#39;, &#39;sprite noselect&#39;);
        this.el.appendChild(input);
        return setTimeout((function(_this) {
          return function() {
            if (!_this.el) {
              return;
            }
            _this.input = _this.el.getElementsByTagName(&#39;input&#39;)[0];
            _this.input.$view = _this.el.$view;
            return $(input).on(&#39;focus blur&#39;, _this.handle);
          };
        })(this), 0);
      };

      Sprite.prototype.getAbsolute = function() {
        var pos;
        if (this.jqel == null) {
          this.jqel = $(this.el);
        }
        pos = this.jqel.offset();
        return {
          x: pos.left,
          y: pos.top
        };
      };

      Sprite.prototype.set_class = function(classname) {
        return this.el.setAttribute(&#39;class&#39;, classname);
      };

      return Sprite;

    })();
    ignoredAttributes = {
      parent: true,
      id: true,
      name: true,
      &quot;extends&quot;: true,
      type: true,
      scriptincludes: true
    };

<span id='dr-view'>    /**
</span>     * @class dr.view
     * @extends dr.node
     * The visual base class for everything in dreem. Views extend dr.node to add the ability to set and animate visual attributes, and interact with the mouse.
     *
     * Views are positioned inside their parent according to their x and y coordinates.
     * 
     * Views can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     *
     * Views can be easily converted to reusable classes/tags by changing their outermost &amp;lt;view&gt; tags to &amp;lt;class&gt; and adding a name attribute.
     *
     * Views support a number of builtin attributes. Setting attributes that aren&#39;t listed explicitly will pass through to the underlying Sprite implementation.
     * 
     * Views currently integrate with jQuery, so any changes made to their CSS via jQuery will automatically cause them to update.
     * 
     * Note that dreem apps must be contained inside a top-level &amp;lt;view&gt;&amp;lt;/view&gt; tag.
     */
    View = (function(_super) {
      __extends(View, _super);


<span id='dr-view-cfg-x'>      /**
</span>       * @cfg {Number} [x=0]
       * This view&#39;s x position
       */


<span id='dr-view-cfg-y'>      /**
</span>       * @cfg {Number} [y=0]
       * This view&#39;s y position
       */


<span id='dr-view-cfg-width'>      /**
</span>       * @cfg {Number} [width=0]
       * This view&#39;s width
       */


<span id='dr-view-cfg-height'>      /**
</span>       * @cfg {Number} [height=0]
       * This view&#39;s height
       */


<span id='dr-view-cfg-clickable'>      /**
</span>       * @cfg {Boolean} [clickable=false]
       * If true, this view recieves mouse events. Automatically set to true when an onclick/mouse* event is registered for this view.
       */


<span id='dr-view-cfg-clip'>      /**
</span>       * @cfg {Boolean} [clip=false]
       * If true, this view clips to its bounds
       */


<span id='dr-view-cfg-visible'>      /**
</span>       * @cfg {Boolean} [visible=true]
       * If false, this view is invisible
       */


<span id='dr-view-cfg-bgcolor'>      /**
</span>       * @cfg {String} bgcolor
       * Sets this view&#39;s background color
       */


<span id='dr-view-event-onclick'>      /**
</span>       * @event onclick 
       * Fired when this view is clicked
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-view-event-onmouseover'>      /**
</span>       * @event onmouseover 
       * Fired when the mouse moves over this view
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-view-event-onmouseout'>      /**
</span>       * @event onmouseout 
       * Fired when the mouse moves off this view
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-view-event-onmousedown'>      /**
</span>       * @event onmousedown 
       * Fired when the mouse goes down on this view
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-view-event-onmouseup'>      /**
</span>       * @event onmouseup 
       * Fired when the mouse goes up on this view
       * @param {dr.view} view The dr.view that fired the event
       */

      function View(el, attributes) {
        var key, type, types, _ref;
        if (attributes == null) {
          attributes = {};
        }

<span id='dr-view-property-subviews'>        /**
</span>         * @property {dr.view[]} subviews
         * @readonly
         * An array of this views&#39;s child views
         */

<span id='dr-view-event-onsubviews'>        /**
</span>         * @event onsubviews 
         * Fired when this views&#39;s subviews array has changed
         * @param {dr.view} view The dr.view that fired the event
         */

<span id='dr-view-property-layouts'>        /**
</span>         * @property {dr.layout[]} layouts
         * @readonly
         * An array of this views&#39;s layouts. Only defined when needed.
         */

<span id='dr-view-event-onlayouts'>        /**
</span>         * @event onlayouts 
         * Fired when this views&#39;s layouts array has changed
         * @param {dr.layout} view The dr.layout that fired the event
         */

<span id='dr-view-property-ignorelayout'>        /**
</span>         * @property {Boolean} ignorelayout
         * If true, layouts should ignore this view
         */
        this.subviews = [];
        types = {
          x: &#39;number&#39;,
          y: &#39;number&#39;,
          width: &#39;number&#39;,
          height: &#39;number&#39;,
          clickable: &#39;boolean&#39;,
          clip: &#39;boolean&#39;,
          visible: &#39;boolean&#39;
        };
        for (key in types) {
          type = types[key];
          if (!(key in attributes)) {
            this[key] = type === &#39;number&#39; ? 0 : false;
          }
        }
        _ref = attributes.$types;
        for (key in _ref) {
          type = _ref[key];
          types[key] = type;
        }
        attributes.$types = types;
        if (__indexOf.call(attributes, &#39;visible&#39;) &lt; 0) {
          attributes.visible = true;
        }
        if (el instanceof View) {
          el = el.sprite;
        }
        this.sprite = new Sprite(el, this, attributes.$tagname);
        View.__super__.constructor.apply(this, arguments);
      }

      View.prototype.setAttribute = function(name, value, skip) {
        if (!(skip || name in ignoredAttributes || this[name] === value)) {
          this.sprite.setStyle(name, value);
        }
        return View.__super__.setAttribute.apply(this, arguments);
      };

      View.prototype.set_clickable = function(clickable) {
        return this.sprite.set_clickable(clickable);
      };

      View.prototype.set_parent = function(parent) {
        View.__super__.set_parent.apply(this, arguments);
        if (parent instanceof View) {
          parent.subviews.push(this);
          parent.sendEvent(&#39;subviews&#39;, this);
          parent = parent.sprite;
        }
        return this.sprite.set_parent(parent);
      };

      View.prototype.set_id = function(id) {
        View.__super__.set_id.apply(this, arguments);
        return this.sprite.set_id(id);
      };


<span id='dr-view-method-animate'>      /**
</span>       * Animates this view&#39;s attribute(s)
       * @param {Object} obj A hash of attribute names and values to animate to
       */

      View.prototype.animate = function() {
        this.sprite.animate.apply(this, arguments);
        return this;
      };

      View.prototype.set_clip = function(clip) {
        return this.sprite.set_clip(clip);
      };

      View.prototype.destroy = function(skipevents) {
        View.__super__.destroy.apply(this, arguments);
        if (!skipevents) {
          this._removeFromParent(&#39;subviews&#39;);
        }
        this.sprite.destroy();
        return this.sprite = null;
      };

      View.prototype.getAbsolute = function() {
        return this.sprite.getAbsolute();
      };

      View.prototype.set_class = function(classname) {
        return this.sprite.set_class(classname);
      };

      return View;

    })(Node);
    dom = (function() {
      var builtinTags, exports, findAutoIncludes, flattenattributes, htmlDecode, initAllElements, initElement, initFromElement, processSpecialTags, specialtags, writeCSS;
      flattenattributes = function(namednodemap) {
        var attributes, i, _i, _len;
        attributes = {};
        for (_i = 0, _len = namednodemap.length; _i &lt; _len; _i++) {
          i = namednodemap[_i];
          attributes[i.name] = i.value;
        }
        return attributes;
      };
      initFromElement = function(el) {
        el.style.display = &#39;none&#39;;
        return findAutoIncludes(el, function() {
          el.style.display = null;
          initElement(el);
          return _initConstraints();
        });
      };
      findAutoIncludes = function(parentel, callback) {
        var cb, includedScripts, includerequests, inlineclasses, jqel, loadIncludes, loadLZX, loadScript, loadqueue, lzxloaded, lzxrequests, scriptloading;
        jqel = $(parentel);
        includerequests = [];
        includedScripts = {};
        loadqueue = [];
        scriptloading = false;
        loadScript = function(url, cb) {
          var appendScript, appendcallback;
          if (url in includedScripts) {
            return;
          }
          includedScripts[url] = true;
          if (scriptloading) {
            loadqueue.push(url);
            return url;
          }
          appendScript = function(url, cb) {
            var script;
            scriptloading = url;
            script = document.createElement(&#39;script&#39;);
            script.type = &#39;text/javascript&#39;;
            $(&#39;head&#39;).append(script);
            script.onload = cb;
            script.onerror = function() {
              console.error(&#39;failed to load scriptinclude&#39;, url);
              return cb();
            };
            return script.src = url;
          };
          appendcallback = function() {
            scriptloading = false;
            if (loadqueue.length === 0) {
              return cb();
            } else {
              return appendScript(loadqueue.shift(), appendcallback);
            }
          };
          return appendScript(url, appendcallback);
        };
        inlineclasses = {};
        lzxrequests = [];
        lzxloaded = {};
        loadLZX = function(name, el) {
          var prom, url, _ref;
          if (name in dr || name in lzxloaded || __indexOf.call(specialtags, name) &gt;= 0 || name in inlineclasses || __indexOf.call(builtinTags, name) &gt;= 0) {
            return;
          }
          if (_ref = el.parentNode.localName, __indexOf.call(specialtags, _ref) &gt;= 0) {
            return;
          }
          lzxloaded[name] = true;
          url = &#39;/classes/&#39; + name + &#39;.lzx&#39;;
          prom = $.get(url);
          prom.url = url;
          prom.el = el;
          return lzxrequests.push(prom);
        };
        loadIncludes = function(callback) {
          var jel, _i, _len, _ref;
          _ref = jqel.find(&#39;include&#39;);
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            jel = _ref[_i];
            includerequests.push($.get(jel.attributes.href.value));
          }
          return $.when.apply($, includerequests).done(function() {
            var args, el, extendz, html, includeRE, initONE, name, xhr, _j, _k, _len1, _len2, _ref1;
            args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
            if (includerequests.length === 1) {
              args = [args];
            }
            includeRE = /&lt;[\/]*library&gt;/gi;
            initONE = false;
            for (_j = 0, _len1 = args.length; _j &lt; _len1; _j++) {
              xhr = args[_j];
              html = xhr[0].replace(includeRE, &#39;&#39;);
              jqel.prepend(html);
            }
            _ref1 = jqel.find(&#39;*&#39;);
            for (_k = 0, _len2 = _ref1.length; _k &lt; _len2; _k++) {
              el = _ref1[_k];
              name = el.localName;
              if (name === &#39;class&#39;) {
                if (el.attributes[&quot;extends&quot;]) {
                  extendz = el.attributes[&quot;extends&quot;].value;
                  loadLZX(extendz, el);
                  if (extendz = &#39;state&#39;) {
                    initONE = true;
                  }
                }
                inlineclasses[el.attributes.name.value] = true;
              } else if (name === &#39;state&#39;) {
                initONE = true;
              } else {
                loadLZX(name, el);
              }
            }
            return $.when.apply($, lzxrequests).done(function() {
              var args, scriptsloading, url, _l, _len3, _len4, _len5, _m, _n, _ref2, _ref3;
              args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
              if (lzxrequests.length === 1) {
                args = [args];
              }
              for (_l = 0, _len3 = args.length; _l &lt; _len3; _l++) {
                xhr = args[_l];
                jqel.prepend(xhr[0]);
              }
              scriptsloading = false;
              if (initONE) {
                scriptsloading = loadScript(&#39;/lib/one_base.js&#39;, function() {
                  ONE.base_.call(Eventable.prototype);
                  Eventable.prototype.enumfalse(Eventable.prototype.keys());
                  Node.prototype.enumfalse(Node.prototype.keys());
                  View.prototype.enumfalse(View.prototype.keys());
                  Layout.prototype.enumfalse(Layout.prototype.keys());
                  return callback();
                });
              }
              _ref2 = jqel.find(&#39;[scriptincludes]&#39;);
              for (_m = 0, _len4 = _ref2.length; _m &lt; _len4; _m++) {
                el = _ref2[_m];
                _ref3 = el.attributes.scriptincludes.value.split(&#39;,&#39;);
                for (_n = 0, _len5 = _ref3.length; _n &lt; _len5; _n++) {
                  url = _ref3[_n];
                  scriptsloading = loadScript(url, callback);
                }
              }
              lzxrequests = [];
              if (!scriptsloading) {
                return callback();
              }
            }).fail(function() {
              var args, _l, _len3, _results;
              args = 1 &lt;= arguments.length ? __slice.call(arguments, 0) : [];
              if (args.length === 1) {
                args = [args];
              }
              _results = [];
              for (_l = 0, _len3 = args.length; _l &lt; _len3; _l++) {
                xhr = args[_l];
                _results.push(console.error(&#39;failed to load&#39;, xhr.url, &#39;for element&#39;, xhr.el));
              }
              return _results;
            });
          });
        };
        cb = function() {
          return loadIncludes(callback);
        };
        return loadIncludes(cb);
      };
      specialtags = [&#39;handler&#39;, &#39;method&#39;, &#39;attribute&#39;, &#39;setter&#39;, &#39;include&#39;];
      builtinTags = [&#39;a&#39;, &#39;abbr&#39;, &#39;address&#39;, &#39;area&#39;, &#39;article&#39;, &#39;aside&#39;, &#39;audio&#39;, &#39;b&#39;, &#39;base&#39;, &#39;bdi&#39;, &#39;bdo&#39;, &#39;blockquote&#39;, &#39;body&#39;, &#39;br&#39;, &#39;button&#39;, &#39;canvas&#39;, &#39;caption&#39;, &#39;cite&#39;, &#39;code&#39;, &#39;col&#39;, &#39;colgroup&#39;, &#39;command&#39;, &#39;datalist&#39;, &#39;dd&#39;, &#39;del&#39;, &#39;details&#39;, &#39;dfn&#39;, &#39;div&#39;, &#39;dl&#39;, &#39;dt&#39;, &#39;em&#39;, &#39;embed&#39;, &#39;fieldset&#39;, &#39;figcaption&#39;, &#39;figure&#39;, &#39;footer&#39;, &#39;form&#39;, &#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;, &#39;h4&#39;, &#39;h5&#39;, &#39;h6&#39;, &#39;head&#39;, &#39;header&#39;, &#39;hgroup&#39;, &#39;hr&#39;, &#39;html&#39;, &#39;i&#39;, &#39;iframe&#39;, &#39;img&#39;, &#39;input&#39;, &#39;ins&#39;, &#39;kbd&#39;, &#39;keygen&#39;, &#39;label&#39;, &#39;legend&#39;, &#39;li&#39;, &#39;link&#39;, &#39;map&#39;, &#39;mark&#39;, &#39;menu&#39;, &#39;meta&#39;, &#39;meter&#39;, &#39;nav&#39;, &#39;noscript&#39;, &#39;object&#39;, &#39;ol&#39;, &#39;optgroup&#39;, &#39;option&#39;, &#39;output&#39;, &#39;p&#39;, &#39;param&#39;, &#39;pre&#39;, &#39;progress&#39;, &#39;q&#39;, &#39;rp&#39;, &#39;rt&#39;, &#39;ruby&#39;, &#39;s&#39;, &#39;samp&#39;, &#39;script&#39;, &#39;section&#39;, &#39;select&#39;, &#39;small&#39;, &#39;source&#39;, &#39;span&#39;, &#39;strong&#39;, &#39;style&#39;, &#39;sub&#39;, &#39;summary&#39;, &#39;sup&#39;, &#39;table&#39;, &#39;tbody&#39;, &#39;td&#39;, &#39;textarea&#39;, &#39;tfoot&#39;, &#39;th&#39;, &#39;thead&#39;, &#39;time&#39;, &#39;title&#39;, &#39;tr&#39;, &#39;track&#39;, &#39;u&#39;, &#39;ul&#39;, &#39;var&#39;, &#39;video&#39;, &#39;wbr&#39;];
      initElement = function(el, parent) {
        var attributes, child, children, event, eventname, isstate, li, skiponinit, tagname, _i, _j, _len, _len1, _ref;
        if (el.$init) {
          return;
        }
        el.$init = true;
        tagname = el.localName;
        if (!(tagname in dr)) {
          if (!(__indexOf.call(builtinTags, tagname) &gt;= 0 || __indexOf.call(specialtags, tagname) &gt;= 0)) {
            console.warn(&#39;could not find class for tag&#39;, tagname, el);
          }
          return;
        }
        attributes = flattenattributes(el.attributes);
        attributes.$tagname = tagname;
        for (_i = 0, _len = mouseEvents.length; _i &lt; _len; _i++) {
          event = mouseEvents[_i];
          eventname = &#39;on&#39; + event;
          if (eventname in attributes) {
            if (attributes.clickable !== false) {
              attributes.clickable = true;
            }
            el.removeAttribute(eventname);
          }
        }
        if (parent == null) {
          parent = el.parentNode;
        }
        if (parent != null) {
          attributes.parent = parent;
        }
        li = tagname.lastIndexOf(&#39;state&#39;);
        isstate = li &gt; -1 &amp;&amp; li === tagname.length - 5;
        if (!((tagname === &#39;class&#39;) || isstate)) {
          dom.processSpecialTags(el, attributes, attributes.type);
        }
        attributes.$skiponinit = skiponinit = ((function() {
          var _j, _len1, _ref, _results;
          _ref = el.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j &lt; _len1; _j++) {
            child = _ref[_j];
            if (child.nodeType === 1) {
              _results.push(child);
            }
          }
          return _results;
        })()).length &gt; 0;
        parent = new dr[tagname](el, attributes);
        if (!(tagname === &#39;class&#39; || isstate)) {
          children = (function() {
            var _j, _len1, _ref, _results;
            _ref = el.childNodes;
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j &lt; _len1; _j++) {
              child = _ref[_j];
              if (child.nodeType === 1) {
                _results.push(child);
              }
            }
            return _results;
          })();
          for (_j = 0, _len1 = children.length; _j &lt; _len1; _j++) {
            child = children[_j];
            if (_ref = child.localName, __indexOf.call(specialtags, _ref) &lt; 0) {
              initElement(child, parent);
            }
          }
          if (skiponinit) {
            if (!parent.inited) {
              parent.inited = true;
              parent.sendEvent(&#39;init&#39;, parent);
            }
          }
        }
      };
      writeCSS = function() {
        var style;
        style = document.createElement(&#39;style&#39;);
        style.type = &#39;text/css&#39;;
        style.innerHTML = &#39;.sprite{ position: absolute; pointer-events: none; padding: 0; margin: 0;} .sprite-text{ width: auto; height; auto; white-space: nowrap;  padding: 0; margin: 0;} .hidden{ display: none; } .noselect{ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;} method { display: none; } handler { display: none; } setter { display: none; } class { display:none } node { display:none }&#39;;
        return document.getElementsByTagName(&#39;head&#39;)[0].appendChild(style);
      };
      initAllElements = function(selector) {
        var el, _i, _len, _results;
        if (selector == null) {
          selector = $(&#39;view&#39;).not(&#39;view view&#39;);
        }
        _results = [];
        for (_i = 0, _len = selector.length; _i &lt; _len; _i++) {
          el = selector[_i];
          _results.push(initFromElement(el));
        }
        return _results;
      };
      htmlDecode = function(input) {
        var child, e, out, _i, _len, _ref;
        e = document.createElement(&#39;div&#39;);
        e.innerHTML = input;
        out = &#39;&#39;;
        _ref = e.childNodes;
        for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
          child = _ref[_i];
          if ((child.nodeValue != null) &amp;&amp; child.nodeType === 3) {
            out += child.nodeValue;
          } else {
            return;
          }
        }
        return out;
      };
      processSpecialTags = function(el, classattributes, defaulttype) {
        var args, attributes, child, children, handler, name, script, tagname, type, _base, _base1, _i, _len, _name, _ref, _ref1;
        if (classattributes.$types == null) {
          classattributes.$types = {};
        }
        if (classattributes.$methods == null) {
          classattributes.$methods = {};
        }
        if (classattributes.$handlers == null) {
          classattributes.$handlers = [];
        }
        children = (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = el.childNodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
            child = _ref[_i];
            if (child.nodeType === 1 &amp;&amp; (_ref1 = child.localName, __indexOf.call(specialtags, _ref1) &gt;= 0)) {
              _results.push(child);
            }
          }
          return _results;
        })();
        for (_i = 0, _len = children.length; _i &lt; _len; _i++) {
          child = children[_i];
          attributes = flattenattributes(child.attributes);
          tagname = child.localName;
          args = ((_ref = attributes.args) != null ? _ref : &#39;&#39;).split();
          script = htmlDecode(child.innerHTML);
          if (script == null) {
            console.warn(&#39;Invalid&#39;, name, child);
          }
          type = (_ref1 = attributes.type) != null ? _ref1 : defaulttype;
          name = attributes.name;
          switch (tagname) {
            case &#39;handler&#39;:
              handler = {
                name: name,
                script: compiler.transform(script, type),
                args: args,
                reference: attributes.reference,
                method: attributes.method
              };
              classattributes.$handlers.push(handler);
              break;
            case &#39;method&#39;:
              if ((_base = classattributes.$methods)[name] == null) {
                _base[name] = [];
              }
              classattributes.$methods[name].push({
                method: compiler.transform(script, type),
                args: args,
                allocation: attributes.allocation
              });
              break;
            case &#39;setter&#39;:
              if ((_base1 = classattributes.$methods)[_name = &#39;set_&#39; + name] == null) {
                _base1[_name] = [];
              }
              classattributes.$methods[&#39;set_&#39; + name].push({
                method: compiler.transform(script, type),
                args: args,
                allocation: attributes.allocation
              });
              break;
            case &#39;attribute&#39;:
              classattributes[name] = attributes.value;
              classattributes.$types[name] = attributes.type;
          }
        }
        return children;
      };
      return exports = {
        initAllElements: initAllElements,
        initElement: initElement,
        processSpecialTags: processSpecialTags,
        writeCSS: writeCSS
      };
    })();

<span id='dr-state'>    /**
</span>     * @class dr.state
     * @extends dr.node
     * Allows a group of attributes, methods, handlers and instances to be removed and applied as a group.
     * 
     * Like views and nodes, states can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     *
     * Currently, states must end with the string &#39;state&#39; in their name to work properly.
     */
    State = (function(_super) {
      __extends(State, _super);

      function State(el, attributes) {
        var child, compilertype, handler, instancebody, name, oldbody, processedChildren, value, _i, _j, _len, _len1, _ref, _ref1;
        if (attributes == null) {
          attributes = {};
        }
        this.skipattributes = [&#39;parent&#39;, &#39;types&#39;, &#39;applyattributes&#39;, &#39;applied&#39;, &#39;skipattributes&#39;, &#39;stateattributes&#39;];
        this.stateattributes = attributes;
        this.applyattributes = {};
        this.applied = false;
        compilertype = attributes.type;
        processedChildren = dom.processSpecialTags(el, attributes, compilertype);
        oldbody = el.innerHTML.trim();
        for (_i = 0, _len = processedChildren.length; _i &lt; _len; _i++) {
          child = processedChildren[_i];
          child.parentNode.removeChild(child);
        }
        instancebody = el.innerHTML.trim();
        if (oldbody) {
          el.innerHTML = oldbody;
        }
        this.types = (_ref = attributes.$types) != null ? _ref : {};
        this.setAttribute(&#39;parent&#39;, attributes.parent);
        this.installMethods(attributes.$methods, this.parent.$tagname, this, this.parent);
        if (attributes.name) {
          this.setAttribute(&#39;name&#39;, attributes.name);
          this.skipattributes.push(&#39;name&#39;);
        }
        if (attributes.applied) {
          this.bindAttribute(&#39;applied&#39;, attributes.applied, &#39;state&#39;);
        }
        _ref1 = attributes.$handlers;
        for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {
          handler = _ref1[_j];
          if (handler.name === &#39;onapplied&#39;) {
            this.installHandlers([handler], &#39;state&#39;, this);
            this._bindHandlers();
          }
        }
        for (name in attributes) {
          value = attributes[name];
          if (!(__indexOf.call(this.skipattributes, name) &gt;= 0 || name.charAt(0) === &#39;$&#39;)) {
            this.applyattributes[name] = value;
            this.setAttribute(name, value);
          }
        }
        if (this.constraints) {
          this._bindConstraints();
          this.skipattributes.push(&#39;constraints&#39;);
        }
        if (this.events) {
          this.skipattributes.push(&#39;events&#39;);
        }
        this.enumfalse(this.skipattributes);
        this.enumfalse(this.keys);
      }


<span id='dr-state-event-onapplied'>      /**
</span>       * @event onapplied 
       * Fired when the state has been applied or unapplied. Onapplied handlers run in the scope of the state itself, see dragstate for an example.
       * @param {Boolean} applied If true, the state was applied.
       */


<span id='dr-state-cfg-applied'>      /**
</span>       * @cfg {Boolean} [applied=false]
       * If true, the state is applied.
       */

      State.prototype.set_applied = function(applied) {
        var name, parentname, val, _results;
        if (!this.parent) {
          return;
        }
        if (this.applied === applied) {
          return;
        }
        this.applied = applied;
        if (applied) {
          this.parent.learn(this);
          if (this.stateattributes.$handlers) {
            this.parent.installHandlers(this.stateattributes.$handlers, this.parent.$tagname, this.parent);
            this.parent._bindHandlers();
          }
        } else {
          this.parent.forget(this);
          if (this.stateattributes.$handlers) {
            this.parent.removeHandlers(this.stateattributes.$handlers, this.parent.$tagname, this.parent);
          }
        }
        parentname = this.parent.$tagname;
        _results = [];
        for (name in this.applyattributes) {
          val = this.parent[name];
          if (val === void 0) {
            continue;
          }
          this.parent[name] = !val;
          _results.push(this.parent.bindAttribute(name, val, parentname));
        }
        return _results;
      };

      State.prototype.apply = function() {
        if (!this.applied) {
          return this.setAttribute(&#39;applied&#39;, true);
        }
      };

      State.prototype.remove = function() {
        if (this.applied) {
          return this.setAttribute(&#39;applied&#39;, false);
        }
      };

      return State;

    })(Node);

<span id='dr-class'>    /**
</span>     * @class dr.class
     * Allows new tags to be created. Classes only be created with the &amp;lt;class&gt;&amp;lt;/class&gt; tag syntax. 
     * 
     * Classes can extend any other class, and they extend dr.view by default. 
     * 
     * Once declared, classes invoked with the declarative syntax, e.g. &amp;lt;classname&gt;&amp;lt;/classname&gt;.
     * 
     * If a class can&#39;t be found in the document, dreem will automatically attempt to load it from the classes/* directory.
     *
     * Like views and nodes, classes can contain methods, handlers, setters, constraints, attributes and other view, node or class instances.
     */
    Class = (function() {

<span id='dr-class-cfg-name'>      /**
</span>       * @cfg {String} name (required)
       * The name of the new tag.
       */

<span id='dr-class-cfg-extends'>      /**
</span>       * @cfg {String} [extends=view] 
       * The name of a class that should be extended.
       */

<span id='dr-class-cfg-type'>      /**
</span>       * @cfg {&quot;js&quot;/&quot;coffee&quot;} [type=js] 
       * The default compiler to use for methods, setters and handlers. Either &#39;js&#39; or &#39;coffee&#39;
       */
      var clone;

      clone = function(obj) {
        var name, newobj, val;
        newobj = {};
        for (name in obj) {
          val = obj[name];
          newobj[name] = val;
        }
        return newobj;
      };

      function Class(el, classattributes) {
        var child, compilertype, extend, haschildren, ignored, instancebody, name, oldbody, processedChildren, _i, _len;
        if (classattributes == null) {
          classattributes = {};
        }
        name = classattributes.name;
        extend = classattributes[&quot;extends&quot;] != null ? classattributes[&quot;extends&quot;] : classattributes[&quot;extends&quot;] = &#39;view&#39;;
        compilertype = classattributes.type;
        for (ignored in ignoredAttributes) {
          delete classattributes[ignored];
        }
        processedChildren = dom.processSpecialTags(el, classattributes, compilertype);
        oldbody = el.innerHTML.trim();
        for (_i = 0, _len = processedChildren.length; _i &lt; _len; _i++) {
          child = processedChildren[_i];
          child.parentNode.removeChild(child);
        }
        haschildren = ((function() {
          var _j, _len1, _ref, _results;
          _ref = el.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j &lt; _len1; _j++) {
            child = _ref[_j];
            if (child.nodeType === 1) {
              _results.push(child);
            }
          }
          return _results;
        })()).length &gt; 0;
        instancebody = el.innerHTML.trim();
        if (oldbody) {
          el.innerHTML = oldbody;
        }
        if (name in dr) {
          console.warn(&#39;overwriting class&#39;, name);
        }
        dr[name] = function(instanceel, instanceattributes) {
          var attributes, children, key, parent, propname, val, value, viewel, _j, _len1, _ref;
          attributes = clone(classattributes);
          for (key in instanceattributes) {
            value = instanceattributes[key];
            if ((key === &#39;$methods&#39; || key === &#39;$types&#39;) &amp;&amp; key in attributes) {
              attributes[key] = clone(attributes[key]);
              for (propname in value) {
                val = value[propname];
                if (key === &#39;$methods&#39; &amp;&amp; attributes[key][propname]) {
                  attributes[key][propname] = attributes[key][propname].concat(val);
                } else {
                  attributes[key][propname] = val;
                }
              }
            } else if (key === &#39;$handlers&#39; &amp;&amp; key in attributes) {
              attributes[key] = attributes[key].concat(value);
            } else {
              attributes[key] = value;
            }
          }
          if (!(extend in dr)) {
            console.warn(&#39;could not find class for tag&#39;, extend);
            return;
          }
          if (attributes.$tagname === &#39;class&#39; || !attributes.$tagname) {
            attributes.$tagname = name;
          }
          attributes.$skiponinit = true;
          attributes.$deferbindings = haschildren;
          parent = new dr[extend](instanceel, attributes);
          viewel = (_ref = parent.sprite) != null ? _ref.el : void 0;
          if (instanceel) {
            if (!viewel) {
              instanceel.setAttribute(&#39;class&#39;, &#39;hidden&#39;);
            }
          }
          if (instancebody &amp;&amp; viewel) {
            if (viewel.innerHTML) {
              viewel.innerHTML = instancebody + viewel.innerHTML;
            } else {
              viewel.innerHTML = instancebody;
            }
            children = (function() {
              var _j, _len1, _ref1, _results;
              _ref1 = viewel.childNodes;
              _results = [];
              for (_j = 0, _len1 = _ref1.length; _j &lt; _len1; _j++) {
                child = _ref1[_j];
                if (child.nodeType === 1) {
                  _results.push(child);
                }
              }
              return _results;
            })();
            for (_j = 0, _len1 = children.length; _j &lt; _len1; _j++) {
              child = children[_j];
              dom.initElement(child, parent);
            }
          }
          parent._bindHandlers();
          if (!parent.inited) {
            parent.inited = true;
            parent.sendEvent(&#39;init&#39;, parent);
          }
          return parent;
        };
      }

      return Class;

    })();

<span id='dr-layout'>    /**
</span>     * @class dr.layout
     * @extends dr.node
     * The base class for all layouts. 
     *
     * When a new layout is added, it will automatically create and add itself to a layouts array in its parent. In addition, an onlayouts event is fired in the parent when the layouts array changes. This allows the parent to access the layout(s) later.
     */
    Layout = (function(_super) {
      __extends(Layout, _super);

      function Layout(el, attributes) {
        var subview, subviews, _base, _i, _len;
        if (attributes == null) {
          attributes = {};
        }
        this._added = __bind(this._added, this);
        this.locked = true;
        Layout.__super__.constructor.apply(this, arguments);
        this.listenTo(this.parent, &#39;subviews&#39;, this._added);
        if ((_base = this.parent).layouts == null) {
          _base.layouts = [];
        }
        this.parent.layouts.push(this);
        this.parent.sendEvent(&#39;layouts&#39;, this.parent.layouts);
        subviews = this.parent.subviews;
        if (subviews) {
          for (_i = 0, _len = subviews.length; _i &lt; _len; _i++) {
            subview = subviews[_i];
            this._added(subview);
          }
        }
        this.locked = false;
        this.update();
      }

      Layout.prototype._added = function(child) {
        if (child) {

<span id='dr-layout-event-onsubview'>          /**
</span>           * @event onsubview 
           * Fired when the layout has a new subview. Used to listen for events on the view that the layout cares about.
           * @param {dr.view} child The subview that was added
           */
          if (!child.ignorelayout) {
            this.sendEvent(&#39;subview&#39;, child);
          }
        }
        return this.update(null, child);
      };


<span id='dr-layout-method-update'>      /**
</span>       * @method update
       * @abstract
       * Called when the layout should be updated. Must be implemented to update the position of the subviews
       * @param value The value received from the node that updated
       * @param {dr.node} sender The node that updated
       */


<span id='dr-layout-method-skip'>      /**
</span>       * Determines if a layout should be updated or not, usually called from update
       * @returns {Boolean} If true, skip updating the layout
       */

      Layout.prototype.skip = function() {
        var _ref;
        if (this.locked || (!this.inited) || (!((_ref = this.parent) != null ? _ref.subviews : void 0)) || (this.parent.subviews.length === 0)) {
          return true;
        }
      };

      Layout.prototype.destroy = function(skipevents) {
        this.locked = true;
        Layout.__super__.destroy.apply(this, arguments);
        if (!skipevents) {
          return this._removeFromParent(&#39;layouts&#39;);
        }
      };

      Layout.prototype.set_locked = function(locked) {
        var changed;
        changed = this.locked !== locked;

<span id='dr-layout-property-locked'>        /**
</span>         * @property {Boolean} locked
         * If true, this layout will not update
         */
        this.locked = locked;

<span id='dr-layout-event-onlocked'>        /**
</span>         * @event onlocked 
         * Fired when the layout is locked
         * @param {Boolean} locked If true, the layout is locked
         */
        this.sendEvent(&#39;locked&#39;, locked);
        if (changed &amp;&amp; !locked) {
          return this.update();
        }
      };

      return Layout;

    })(Node);
    idle = (function() {
      var doTick, requestAnimationFrame, tickEvents, ticking;
      requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      ticking = false;
      tickEvents = [];
      doTick = function(time) {
        var key;
        for (key in tickEvents) {
          if (tickEvents[key]) {
            tickEvents[key](time);
            tickEvents[key] = null;
          }
        }
        return ticking = false;
      };
      return function(key, callback) {
        if (!ticking) {
          requestAnimationFrame(doTick);
        }
        ticking = true;
        return tickEvents[key] = callback;
      };
    })();
    StartEventable = (function(_super) {
      __extends(StartEventable, _super);

      function StartEventable() {
        this.stopEvent = __bind(this.stopEvent, this);
        this.startEvent = __bind(this.startEvent, this);
        return StartEventable.__super__.constructor.apply(this, arguments);
      }

      StartEventable.prototype.bind = function(ev, callback) {
        StartEventable.__super__.bind.apply(this, arguments);
        if (this.startEventTest()) {
          return this.startEvent();
        }
      };

      StartEventable.prototype.unbind = function(ev, callback) {
        StartEventable.__super__.unbind.apply(this, arguments);
        if (!this.startEventTest()) {
          return this.stopEvent();
        }
      };

      StartEventable.prototype.startEvent = function(event) {
        if (this.eventStarted) {
          return;
        }
        return this.eventStarted = true;
      };

      StartEventable.prototype.stopEvent = function(event) {
        if (!this.eventStarted) {
          return;
        }
        return this.eventStarted = false;
      };

      return StartEventable;

    })(Eventable);

<span id='dr-idle'>    /**
</span>     * @class dr.idle
     * @extends Eventable
     * Sends onidle events when the application is active and idle.
     */
    Idle = (function(_super) {
      __extends(Idle, _super);

      function Idle() {
        this.sender = __bind(this.sender, this);
        this.startEvent = __bind(this.startEvent, this);
        return Idle.__super__.constructor.apply(this, arguments);
      }

      Idle.prototype.startEventTest = function() {
        var start, _ref;
        start = (_ref = this.events[&#39;idle&#39;]) != null ? _ref.length : void 0;
        if (start) {
          return start;
        }
      };

      Idle.prototype.startEvent = function(event) {
        Idle.__super__.startEvent.apply(this, arguments);
        return idle(1, this.sender);
      };

      Idle.prototype.sender = function(time) {

<span id='dr-idle-event-onidle'>        /**
</span>         * @event onidle 
         * Fired when the application is active and idle.
         * @param {Number} time The number of milliseconds since the application started
         */
        this.sendEvent(&#39;idle&#39;, time);
        return setTimeout((function(_this) {
          return function() {
            return idle(1, _this.sender);
          };
        })(this), 0);
      };

      return Idle;

    })(StartEventable);
    mouseEvents = [&#39;click&#39;, &#39;mouseover&#39;, &#39;mouseout&#39;, &#39;mousedown&#39;, &#39;mouseup&#39;];

<span id='dr-mouse'>    /**
</span>     * @class dr.mouse
     * @extends Eventable
     * Sends mouse events. Often used to listen to onmouseover/x/y events to follow the mouse position.
     */
    Mouse = (function(_super) {
      __extends(Mouse, _super);


<span id='dr-mouse-event-onclick'>      /**
</span>       * @event onclick 
       * Fired when the mouse is clicked
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-mouse-event-onmouseover'>      /**
</span>       * @event onmouseover 
       * Fired when the mouse moves over a view
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-mouse-event-onmouseout'>      /**
</span>       * @event onmouseout 
       * Fired when the mouse moves off a view
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-mouse-event-onmousedown'>      /**
</span>       * @event onmousedown 
       * Fired when the mouse goes down on a view
       * @param {dr.view} view The dr.view that fired the event
       */


<span id='dr-mouse-event-onmouseup'>      /**
</span>       * @event onmouseup 
       * Fired when the mouse goes up on a view
       * @param {dr.view} view The dr.view that fired the event
       */

      function Mouse() {
        this.sender = __bind(this.sender, this);
        this.handle = __bind(this.handle, this);
        this.x = 0;
        this.y = 0;
        this.docSelector = $(document);
        this.docSelector.on(mouseEvents.join(&#39; &#39;), this.handle);
        this.docSelector.on(&quot;mousemove&quot;, this.handle).one(&quot;mouseout&quot;, this.stopEvent);
      }

      Mouse.prototype.startEventTest = function() {
        var _ref, _ref1, _ref2;
        return ((_ref = this.events[&#39;mousemove&#39;]) != null ? _ref.length : void 0) || ((_ref1 = this.events[&#39;x&#39;]) != null ? _ref1.length : void 0) || ((_ref2 = this.events[&#39;y&#39;]) != null ? _ref2.length : void 0);
      };

      Mouse.prototype.handle = function(event) {
        var type, view;
        view = event.target.$view;
        type = event.type;
        if (view) {
          view.sendEvent(type, view);
        }
        if (this.eventStarted &amp;&amp; type === &#39;mousemove&#39;) {

<span id='dr-mouse-property-x'>          /**
</span>           * @property {Number} x
           * @readonly
           * The x coordinate of the mouse
           */
          this.x = event.pageX;

<span id='dr-mouse-property-y'>          /**
</span>           * @property {Number} y
           * @readonly
           * The y coordinate of the mouse
           */
          this.y = event.pageY;
          return idle(0, this.sender);
        } else {
          return this.sendEvent(type, view);
        }
      };

      Mouse.prototype.sender = function() {

<span id='dr-mouse-event-onmousemove'>        /**
</span>         * @event onmousemove 
         * Fired when the mouse moves
         * @param {Object} coordinates The x and y coordinates of the mouse
         */
        this.sendEvent(&quot;mousemove&quot;, {
          x: this.x,
          y: this.y
        });

<span id='dr-mouse-event-onx'>        /**
</span>         * @event onx 
         * Fired when the mouse moves in the x axis
         * @param {Number} x The x coordinate of the mouse
         */
        this.sendEvent(&#39;x&#39;, this.x);

<span id='dr-mouse-event-ony'>        /**
</span>         * @event ony 
         * Fired when the mouse moves in the y axis
         * @param {Number} y The y coordinate of the mouse
         */
        return this.sendEvent(&#39;y&#39;, this.y);
      };

      Mouse.prototype.handleDocEvent = function(event) {
        if (event &amp;&amp; event.target !== document) {
          return;
        }
        if (this.eventStarted) {
          return this.docSelector.on(&quot;mousemove&quot;, this.handle).one(&quot;mouseout&quot;, this.stopEvent);
        } else {
          return this.docSelector.on(&quot;mousemove&quot;, this.handle).one(&quot;mouseout&quot;, this.startEvent);
        }
      };

      return Mouse;

    })(StartEventable);

<span id='dr-window'>    /**
</span>     * @class dr.window
     * @extends Eventable
     * Sends window resize events. Often used to dynamically reposition views as the window size changes.
     */
    Window = (function(_super) {
      __extends(Window, _super);

      function Window() {
        this.handle = __bind(this.handle, this);
        var handleVisibilityChange, hidden, visibilityChange;
        window.addEventListener(&#39;resize&#39;, this.handle, false);
        this.visible = true;
        if (document.hidden != null) {
          hidden = &quot;hidden&quot;;
          visibilityChange = &quot;visibilitychange&quot;;
        } else if (document.mozHidden != null) {
          hidden = &quot;mozHidden&quot;;
          visibilityChange = &quot;mozvisibilitychange&quot;;
        } else if (document.msHidden != null) {
          hidden = &quot;msHidden&quot;;
          visibilityChange = &quot;msvisibilitychange&quot;;
        } else if (document.webkitHidden != null) {
          hidden = &quot;webkitHidden&quot;;
          visibilityChange = &quot;webkitvisibilitychange&quot;;
        }
        handleVisibilityChange = (function(_this) {
          return function() {
            _this.visible = document[hidden];

<span id='dr-window-event-onvisible'>            /**
</span>             * @event onvisible 
             * Fired when the window visibility changes
             * @param {Boolean} visible True if the window is currently visible
             */
            return _this.sendEvent(&#39;visible&#39;, _this.visible);
          };
        })(this);
        document.addEventListener(visibilityChange, handleVisibilityChange, false);
        this.handle();
      }

      Window.prototype.startEventTest = function() {
        var _ref, _ref1;
        return ((_ref = this.events[&#39;width&#39;]) != null ? _ref.length : void 0) || ((_ref1 = this.events[&#39;height&#39;]) != null ? _ref1.length : void 0);
      };

      Window.prototype.handle = function(event) {
        this.width = window.innerWidth;

<span id='dr-window-event-onwidth'>        /**
</span>         * @event onwidth 
         * Fired when the window resizes
         * @param {Number} width The width of the window
         */
        this.sendEvent(&#39;width&#39;, this.width);
        this.height = window.innerHeight;

<span id='dr-window-event-onheight'>        /**
</span>         * @event onheight 
         * Fired when the window resizes
         * @param {Number} height The height of the window
         */
        return this.sendEvent(&#39;height&#39;, this.height);
      };

      return Window;

    })(StartEventable);

<span id='dr-keyboard'>    /**
</span>     * @class dr.keyboard
     * @extends Eventable
     * Sends keyboard events.
     */
    Keyboard = (function(_super) {
      var keyboardEvents, keys;

      __extends(Keyboard, _super);

      keyboardEvents = [&#39;select&#39;, &#39;keyup&#39;, &#39;keydown&#39;, &#39;change&#39;];

      keys = {
        shiftKey: false,
        altKey: false,
        ctrlKey: false,
        metaKey: false,
        keyCode: 0
      };

      function Keyboard() {
        this.handle = __bind(this.handle, this);
        $(document).on(keyboardEvents.join(&#39; &#39;), this.handle);
      }

      Keyboard.prototype.handle = function(event) {
        var key, out, target, type, value;
        target = event.target.$view;
        type = event.type;
        if (type !== &#39;select&#39;) {
          for (key in keys) {
            value = keys[key];
            keys[key] = event[key];
          }
        }
        keys.type = type;
        if (target) {
          target.sendEvent(type, keys);
          if (type === &#39;keydown&#39; || type === &#39;keyup&#39; || type === &#39;blur&#39; || type === &#39;change&#39;) {
            value = event.target.value;
            if (target.text !== value) {
              target.text = value;
              target.sendEvent(&#39;text&#39;, value);
            }
          }
        }
        out = type === &#39;select&#39; ? target : keys;

<span id='dr-keyboard-event-onselect'>        /**
</span>         * @event onselect 
         * Fired when text is selected
         * @param {dr.view} view The view that fired the event
         */

<span id='dr-keyboard-event-onchange'>        /**
</span>         * @event onchange 
         * Fired when an inputtext has changed
         * @param {dr.view} view The view that fired the event
         */

<span id='dr-keyboard-event-onkeydown'>        /**
</span>         * @event onkeydown 
         * Fired when a key goes down
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */

<span id='dr-keyboard-event-onkeyup'>        /**
</span>         * @event onkeyup 
         * Fired when a key goes up
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */
        this.sendEvent(type, out);

<span id='dr-keyboard-event-onkeys'>        /**
</span>         * @event onkeys 
         * Fired when a key is pressed on the keyboard
         * @param {Object} keys An object representing the keyboard state, including shiftKey, allocation, ctrlKey, metaKey, keyCode and type
         */
        if (type !== &#39;select&#39;) {
          return this.sendEvent(&#39;keys&#39;, out);
        }
      };

      return Keyboard;

    })(Eventable);

<span id='dr'>    /**
</span>     * @class dr
     * Holds builtin and user-created classes and public APIs.
     * 
     * All classes listed here can be invoked with the declarative syntax, e.g. &amp;lt;node&gt;&amp;lt;/node&gt; or &amp;lt;view&gt;&amp;lt;/view&gt;
     */
    return exports = {
      view: View,
      &quot;class&quot;: Class,
      node: Node,
      mouse: new Mouse(),
      keyboard: new Keyboard(),
      window: new Window(),
      layout: Layout,
      idle: new Idle(),
      state: State,

<span id='dr-method-initElements'>      /**
</span>       * @method initElements
       * Initializes all top-level views found in the document. Called automatically when the page loads, but can be called manually as needed.
       */
      initElements: dom.initAllElements,

<span id='dr-method-writeCSS'>      /**
</span>       * @method writeCSS
       * Writes generic dreem-specific CSS to the document. Should only be called once.
       */
      writeCSS: dom.writeCSS
    };

<span id='dr-method'>    /**
</span>     * @class dr.method
     * Declares a method in a node, view, class or other class instance. Methods can only be created with the &amp;lt;method&gt;&amp;lt;/method&gt; tag syntax. 
     * 
     * If a method overrides an existing method, any existing (super) method(s) will be called first automatically.
     */

<span id='dr-method-cfg-name'>    /**
</span>     * @cfg {String} name (required)
     * The name of the method.
     */

<span id='dr-method-cfg-args'>    /**
</span>     * @cfg {String[]} args
     * A comma separated list of method arguments.
     */

<span id='dr-method-cfg-type'>    /**
</span>     * @cfg {&quot;js&quot;/&quot;coffee&quot;} type 
     * The default compiler to use for this method. Inherits from the immediate class if unspecified.
     */

<span id='dr-setter'>    /**
</span>     * @class dr.setter
     * Declares a setter in a node, view, class or other class instance. Setters can only be created with the &amp;lt;setter&gt;&amp;lt;/setter&gt; tag syntax.
     *
     * Setters are called when an attribute is set based on their name, and allow the behavior of an attribute changes to be modified.
     * 
     * If a setter overrides an existing method, any existing (super) method(s) will be called first automatically.
     */

<span id='dr-setter-cfg-name'>    /**
</span>     * @cfg {String} name (required)
     * The name of the method.
     */

<span id='dr-setter-cfg-args'>    /**
</span>     * @cfg {String[]} args
     * A comma separated list of method arguments.
     */

<span id='dr-setter-cfg-type'>    /**
</span>     * @cfg {&quot;js&quot;/&quot;coffee&quot;} type 
     * The default compiler to use for this method. Inherits from the immediate class if unspecified.
     */

<span id='dr-handler'>    /**
</span>     * @class dr.handler
     * Declares a handler in a node, view, class or other class instance. Handlers can only be created with the &amp;lt;handler&gt;&amp;lt;/handler&gt; tag syntax.
     *
     * Handlers are called when an event fires with  new value, if available.
     */

<span id='dr-handler-cfg-name'>    /**
</span>     * @cfg {String} name (required)
     * The name of the event to listen for, e.g. &#39;onwidth&#39;.
     */

<span id='dr-handler-cfg-reference'>    /**
</span>     * @cfg {String} reference
     * If set, the handler will listen for an event in another scope.
     */

<span id='dr-handler-cfg-method'>    /**
</span>     * @cfg {String} method
     * If set, the handler call a local method. Useful when multiple handlers need to do the same thing.
     */

<span id='dr-handler-cfg-args'>    /**
</span>     * @cfg {String[]} args
     * A comma separated list of method arguments.
     */

<span id='dr-handler-cfg-type'>    /**
</span>     * @cfg {&quot;js&quot;/&quot;coffee&quot;} type 
     * The default compiler to use for this method. Inherits from the immediate class if unspecified.
     */

<span id='dr-attribute'>    /**
</span>     * @class dr.attribute
     * Declares an attribute in a node, view, class or other class instance. Attributes can only be created with the &amp;lt;attribute&gt;&amp;lt;/attribute&gt; tag syntax.
     * 
     * Attributes allow classes to declare new variables with a specific type and default value. 
     *
     * Attributes automatically send events when their value changes.
     */

<span id='dr-attribute-cfg-name'>    /**
</span>     * @cfg {String} name (required)
     * The name of the attribute
     */

<span id='dr-attribute-cfg-type'>    /**
</span>     * @cfg {&quot;string&quot;/&quot;number&quot;/&quot;boolean&quot;/&quot;json&quot;} [type=string] (required)
     * The type of the attribute. Used to convert from string to an appropriate representation of the type.
     */

<span id='dr-attribute-cfg-value'>    /**
</span>     * @cfg {String} value (required)
     * The initial value for the attribute
     */
  })();

  dr.writeCSS();

  $(window).on(&#39;load&#39;, function() {
    dr.initElements();
    return hackstyle(true);
  });

}).call(this);

//# sourceMappingURL=layout.map
</pre>
</body>
</html>
